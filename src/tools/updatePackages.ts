#!/usr/bin/env bun
/**
 * Script to update packages with latest data from pkgx.dev
 * Fetches the latest package info and regenerates the index.ts file
 */
import fs from 'node:fs'
import path from 'node:path'
import process from 'node:process'
import { cleanupBrowserResources, fetchPkgxPackage } from '../fetch'
import { fetchPackageListFromGitHub } from '../utils'

// The packages directory path
const PACKAGES_DIR = path.join(process.cwd(), 'src', 'packages')

// Number of packages to update per batch to prevent memory issues
const BATCH_SIZE = 20

/**
 * Generate the exported package name based on the module name
 * @param moduleName The module name (filename without extension)
 * @returns The actual exported package variable name
 */
function getPackageExportName(moduleName: string): string {
  // If the filename has hyphens, they're removed in the actual exported variable name
  // e.g., ast-grepgithubio.ts exports astgrepgithubioPackage
  return `${moduleName.replace(/-/g, '')}Package`
}

/**
 * Update a single package file with latest information
 * @param packageName The name of the package to update
 * @returns Promise resolving to boolean indicating success
 */
export async function updatePackage(packageName: string): Promise<boolean> {
  try {
    console.error(`Updating package ${packageName}...`)

    // Fetch the latest package information
    const { packageInfo, fullDomainName } = await fetchPkgxPackage(packageName, {
      timeout: 60000, // 60 second timeout
    })

    // Convert domain name to TypeScript-friendly format
    const tsName = fullDomainName
      .replace(/\./g, '')
      .replace(/-/g, '')
      .replace(/\//g, '-')
      .toLowerCase()

    // Create the file path
    const filePath = path.join(PACKAGES_DIR, `${tsName}.ts`)

    // Check if file exists
    const fileExists = fs.existsSync(filePath)

    // If file doesn't exist, create a new one
    if (!fileExists) {
      console.error(`Creating new package file for ${packageName} at ${filePath}`)

      // Create package variable name
      const varName = `${tsName}Package`

      // Create TypeScript content
      const tsContent = `import type { PkgxPackage } from '../types'

/**
 * ${varName} information from pkgx.dev
 * Generated by pkgx-tools
 */
export const ${varName}: PkgxPackage = ${JSON.stringify(packageInfo, null, 2)}

export interface ${varName.charAt(0).toUpperCase() + varName.slice(1).replace(/Package$/, 'Package')} {
  name: ${JSON.stringify(packageInfo.name)};
  domain: ${JSON.stringify(packageInfo.domain)};
  description: ${JSON.stringify(packageInfo.description)};
  packageYmlUrl: ${JSON.stringify(packageInfo.packageYmlUrl || '')};
  homepageUrl: ${JSON.stringify(packageInfo.homepageUrl || '')};
  githubUrl: ${JSON.stringify(packageInfo.githubUrl || '')};
  installCommand: ${JSON.stringify(packageInfo.installCommand)};
  programs: readonly ${JSON.stringify(packageInfo.programs)};
  companions: readonly ${JSON.stringify(packageInfo.companions)};
  dependencies: readonly ${JSON.stringify(packageInfo.dependencies)};
  versions: readonly ${JSON.stringify(packageInfo.versions)};
  fullPath: ${JSON.stringify(packageInfo.fullPath || packageName)};
}
`

      // Write the file
      fs.writeFileSync(filePath, tsContent)
      return true
    }

    // File exists, update it
    console.error(`Updating existing package file for ${packageName}`)

    // Read existing file
    const existingContent = fs.readFileSync(filePath, 'utf-8')

    // Get package variable name
    const varName = getPackageExportName(tsName)

    // Create new package object content
    const newPackageContent = JSON.stringify(packageInfo, null, 2)

    // Replace the package object in the file
    const updatedContent = existingContent.replace(
      new RegExp(`export const ${varName}[^{]+{[\\s\\S]+?\\n\\}`, 'm'),
      `export const ${varName}: PkgxPackage = ${newPackageContent}`,
    )

    // Check if content actually changed
    if (updatedContent !== existingContent) {
      // Write the updated file
      fs.writeFileSync(filePath, updatedContent)
      console.error(`Updated package ${packageName}`)
      return true
    }

    console.error(`No changes needed for ${packageName}`)
    return false
  }
  catch (error) {
    console.error(`Error updating package ${packageName}:`, error)
    return false
  }
}

/**
 * Main function to update packages
 */
async function main() {
  try {
    // Check if the packages directory exists
    if (!fs.existsSync(PACKAGES_DIR)) {
      fs.mkdirSync(PACKAGES_DIR, { recursive: true })
    }

    // Get the list of packages to update
    const packages = await fetchPackageListFromGitHub()
    console.error(`Found ${packages.length} packages to update`)

    let updatedCount = 0
    const batches = Math.ceil(packages.length / BATCH_SIZE)

    // Process packages in batches to prevent memory issues
    for (let i = 0; i < batches; i++) {
      const start = i * BATCH_SIZE
      const end = Math.min(start + BATCH_SIZE, packages.length)
      const batch = packages.slice(start, end)

      console.error(`Processing batch ${i + 1}/${batches} (packages ${start + 1}-${end})`)

      // Update packages in the current batch
      const results = await Promise.all(batch.map((pkg: string) => updatePackage(pkg)))

      // Count updated packages
      updatedCount += results.filter(Boolean).length
    }

    console.error(`Updated ${updatedCount} out of ${packages.length} packages`)

    // Regenerate the index.ts file
    console.error(`Regenerating index.ts file...`)

    // Run the generateIndex script directly
    await import('./generateIndex')

    // Clean up resources
    await cleanupBrowserResources()

    console.error(`Package update completed successfully`)

    // Force exit after a small delay to ensure all resources are freed
    setTimeout(() => {
      process.exit(0)
    }, 1000)
  }
  catch (error) {
    console.error('Error updating packages:', error)

    // Make sure to clean up resources
    try {
      await cleanupBrowserResources()
    }
    catch (cleanupError) {
      console.error('Error during cleanup:', cleanupError)
    }

    process.exit(1)
  }
  finally {
    // Make sure to clean up browser resources
    try {
      await cleanupBrowserResources()

      // Force exit after resources are cleaned up
      setTimeout(() => {
        process.exit(0)
      }, 1000)
    }
    catch (error) {
      console.error('Error during final cleanup:', error)
      process.exit(1)
    }
  }
}

// Run the main function
main()
