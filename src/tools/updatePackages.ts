#!/usr/bin/env bun
/**
 * Script to update packages with latest data from pkgx.dev
 * Fetches the latest package info and regenerates the index.ts file
 */
import fs from 'node:fs'
import path from 'node:path'
import process from 'node:process'
import { cleanupBrowserResources, fetchPkgxPackage } from '../fetch'
import { fetchPackageListFromGitHub, formatObjectWithoutQuotedKeys } from '../utils'

// The packages directory path
const PACKAGES_DIR = path.join(process.cwd(), 'src', 'packages')

// Number of packages to update per batch to prevent memory issues
const BATCH_SIZE = 20

/**
 * Generate the exported package name based on the module name
 * @param moduleName The module name (filename without extension)
 * @returns The actual exported package variable name
 */
function getPackageExportName(moduleName: string): string {
  // Remove hyphens to create a valid JavaScript identifier
  // e.g., ast-grepgithubio.ts exports astgrepgithubioPackage
  return `${moduleName.replace(/-/g, '')}Package`
}

/**
 * Convert a domain name to a TypeScript-friendly filename
 * Handles special cases like nested paths and ensures valid identifier names
 * @param domainName The original domain name or path
 * @returns A TypeScript-friendly filename without extension
 */
function getDomainAsTypescriptFileName(domainName: string): string {
  // First handle the case where there are slashes (nested paths)
  if (domainName.includes('/')) {
    // Replace slashes with hyphens for filenames
    return domainName
      .replace(/\//g, '-')
      .replace(/\./g, '')
      .replace(/[^a-zA-Z0-9\-_]/g, '')
      .toLowerCase()
  }

  // For regular domains, just remove dots and special characters
  return domainName
    .replace(/\./g, '')
    .replace(/[^a-zA-Z0-9\-_]/g, '')
    .toLowerCase()
}

/**
 * Update a single package file with latest information
 * @param packageName The name of the package to update
 * @returns Promise resolving to boolean indicating success
 */
export async function updatePackage(packageName: string): Promise<boolean> {
  try {
    console.log(`Updating package ${packageName}...`)

    // Fetch the latest package information
    const { packageInfo, fullDomainName } = await fetchPkgxPackage(packageName, {
      timeout: 60000, // 60 second timeout
    })

    // Sort versions if they exist, using Bun.semver if available
    if (Array.isArray(packageInfo.versions) && packageInfo.versions.length > 0) {
      try {
        // Use Bun.semver to sort versions if available (descending order - newest first)
        if (typeof Bun !== 'undefined' && Bun.semver) {
          packageInfo.versions.sort((a, b) => -1 * Bun.semver.order(a, b))
        } else {
          // Fallback manual sorting when Bun.semver is not available
          packageInfo.versions.sort((a, b) => {
            const aParts = a.split('.').map(Number)
            const bParts = b.split('.').map(Number)

            for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
              const aVal = aParts[i] || 0
              const bVal = bParts[i] || 0
              if (aVal !== bVal) {
                return bVal - aVal // Descending order
              }
            }
            return 0
          })
        }
      } catch (err) {
        console.error(`Error sorting versions: ${err}`)
        // Continue with unsorted versions if sorting fails
      }
    }

    // Convert domain name to TypeScript-friendly format
    const tsName = getDomainAsTypescriptFileName(fullDomainName)

    // Create the file path
    const filePath = path.join(PACKAGES_DIR, `${tsName}.ts`)

    // Check if file exists
    const fileExists = fs.existsSync(filePath)

    // If file doesn't exist, create a new one
    if (!fileExists) {
      console.log(`Creating new package file for ${packageName} at ${filePath}`)

      // Create package variable name - ensure it's a valid JavaScript identifier
      const varName = `${tsName.replace(/-/g, '')}Package`

      // Create TypeScript content
      const tsContent = `import type { PkgxPackage } from '../types'

/**
 * ${varName} information from pkgx.dev
 * Generated by pkgx-tools
 */
export const ${varName}: PkgxPackage = ${formatObjectWithoutQuotedKeys(packageInfo)}

export interface ${varName.charAt(0).toUpperCase() + varName.slice(1).replace(/Package$/, '').replace(/-/g, '')}Package {
  name: ${JSON.stringify(packageInfo.name)};
  domain: ${JSON.stringify(packageInfo.domain)};
  description: ${JSON.stringify(packageInfo.description)};
  packageYmlUrl: ${JSON.stringify(packageInfo.packageYmlUrl || '')};
  homepageUrl: ${JSON.stringify(packageInfo.homepageUrl || '')};
  githubUrl: ${JSON.stringify(packageInfo.githubUrl || '')};
  installCommand: ${JSON.stringify(packageInfo.installCommand)};
  programs: readonly ${Array.isArray(packageInfo.programs) && packageInfo.programs.length > 0
    ? `[${packageInfo.programs.map(p => JSON.stringify(p)).join(', ')}]`
    : '[]'};
  companions: readonly ${Array.isArray(packageInfo.companions) && packageInfo.companions.length > 0
    ? `[${packageInfo.companions.map(c => JSON.stringify(c)).join(', ')}]`
    : '[]'};
  dependencies: readonly ${Array.isArray(packageInfo.dependencies) && packageInfo.dependencies.length > 0
    ? `[${packageInfo.dependencies.map(d => JSON.stringify(d)).join(', ')}]`
    : '[]'};
  versions: readonly ${Array.isArray(packageInfo.versions) && packageInfo.versions.length > 0
    ? `[${packageInfo.versions.map(v => JSON.stringify(v)).join(', ')}]`
    : '[]'}${packageInfo.fullPath ? `;
  fullPath: ${JSON.stringify(packageInfo.fullPath || packageName)}` : ''}
}`

      // Write the file
      fs.writeFileSync(filePath, tsContent)
      return true
    }

    // File exists, update it
    console.log(`Updating existing package file for ${packageName}`)

    // Read existing file
    const existingContent = fs.readFileSync(filePath, 'utf-8')

    // Get package variable name
    const varName = getPackageExportName(tsName)

    // Create the interface name - should match the existing format
    const interfaceName = `${varName.charAt(0).toUpperCase() + varName.slice(1).replace(/Package$/, '').replace(/-/g, '')}Package`

    // Create new package object content using our formatter
    const newPackageContent = formatObjectWithoutQuotedKeys(packageInfo)

    // Create the new interface content
    const newInterfaceContent = `export interface ${interfaceName} {
  name: ${JSON.stringify(packageInfo.name)};
  domain: ${JSON.stringify(packageInfo.domain)};
  description: ${JSON.stringify(packageInfo.description)};
  packageYmlUrl: ${JSON.stringify(packageInfo.packageYmlUrl || '')};
  homepageUrl: ${JSON.stringify(packageInfo.homepageUrl || '')};
  githubUrl: ${JSON.stringify(packageInfo.githubUrl || '')};
  installCommand: ${JSON.stringify(packageInfo.installCommand)};
  programs: readonly ${Array.isArray(packageInfo.programs) && packageInfo.programs.length > 0
    ? `[${packageInfo.programs.map(p => JSON.stringify(p)).join(', ')}]`
    : '[]'};
  companions: readonly ${Array.isArray(packageInfo.companions) && packageInfo.companions.length > 0
    ? `[${packageInfo.companions.map(c => JSON.stringify(c)).join(', ')}]`
    : '[]'};
  dependencies: readonly ${Array.isArray(packageInfo.dependencies) && packageInfo.dependencies.length > 0
    ? `[${packageInfo.dependencies.map(d => JSON.stringify(d)).join(', ')}]`
    : '[]'};
  versions: readonly ${Array.isArray(packageInfo.versions) && packageInfo.versions.length > 0
    ? `[${packageInfo.versions.map(v => JSON.stringify(v)).join(', ')}]`
    : '[]'}${packageInfo.fullPath ? `;
  fullPath: ${JSON.stringify(packageInfo.fullPath || packageName)}` : ''}
}`

    // First, remove all duplicated interface declarations from the file
    let cleanedContent = existingContent.replace(
      new RegExp(`export interface ${interfaceName} {[\\s\\S]+?\\n\\}`, 'gm'),
      ''
    );

    // Replace the package object in the cleaned file
    let updatedContent = cleanedContent.replace(
      new RegExp(`export const ${varName}[^{]+{[\\s\\S]+?\\n\\}`, 'm'),
      `export const ${varName}: PkgxPackage = ${newPackageContent}`
    );

    // Add the interface definition after the constant
    updatedContent = updatedContent.replace(
      new RegExp(`export const ${varName}[^{]+{[\\s\\S]+?\\n\\}`, 'm'),
      `export const ${varName}: PkgxPackage = ${newPackageContent}\n\n${newInterfaceContent}`
    );

    // Check if content actually changed
    if (updatedContent !== existingContent) {
      // Write the updated file
      fs.writeFileSync(filePath, updatedContent)
      console.error(`Updated package ${packageName}`)
      return true
    }

    console.log(`No changes needed for ${packageName}`)
    return false
  }
  catch (error) {
    console.error(`Error updating package ${packageName}:`, error)
    return false
  }
}

/**
 * Update a single package file with latest information
 * This function is a specialized version that only updates one package for use with CLI
 * @param packageName The name of the package to update
 * @returns Promise resolving to boolean indicating success
 */
export async function updateSinglePackage(packageName: string): Promise<boolean> {
  try {
    console.log(`Updating package ${packageName}...`)

    // Validate that the package name is legitimate and not a path
    if (packageName.startsWith('/') || packageName.includes('/bin/')) {
      console.error(`Error: '${packageName}' appears to be a path, not a valid package name.`)
      return false
    }

    // Create packages directory if it doesn't exist
    if (!fs.existsSync(PACKAGES_DIR)) {
      fs.mkdirSync(PACKAGES_DIR, { recursive: true })
    }

    // Fetch the latest package information
    const { packageInfo, fullDomainName } = await fetchPkgxPackage(packageName, {
      timeout: 60000, // 60 second timeout
    })

    // Sort versions if they exist, using Bun.semver if available
    if (Array.isArray(packageInfo.versions) && packageInfo.versions.length > 0) {
      try {
        // Use Bun.semver to sort versions if available (descending order - newest first)
        if (typeof Bun !== 'undefined' && Bun.semver) {
          packageInfo.versions.sort((a, b) => -1 * Bun.semver.order(a, b))
        } else {
          // Fallback manual sorting when Bun.semver is not available
          packageInfo.versions.sort((a, b) => {
            const aParts = a.split('.').map(Number)
            const bParts = b.split('.').map(Number)

            for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
              const aVal = aParts[i] || 0
              const bVal = bParts[i] || 0
              if (aVal !== bVal) {
                return bVal - aVal // Descending order
              }
            }
            return 0
          })
        }
      } catch (err) {
        console.error(`Error sorting versions: ${err}`)
        // Continue with unsorted versions if sorting fails
      }
    }

    // Convert domain name to TypeScript-friendly format
    const tsName = getDomainAsTypescriptFileName(fullDomainName)

    // Create the file path
    const filePath = path.join(PACKAGES_DIR, `${tsName}.ts`)

    // Check if file exists
    const fileExists = fs.existsSync(filePath)

    // If file doesn't exist, create a new one
    if (!fileExists) {
      console.log(`Creating new package file for ${packageName} at ${filePath}`)

      // Create package variable name - ensure it's a valid JavaScript identifier
      const varName = `${tsName.replace(/-/g, '')}Package`

      // Create TypeScript content
      const tsContent = `import type { PkgxPackage } from '../types'

/**
 * ${varName} information from pkgx.dev
 * Generated by pkgx-tools
 */
export const ${varName}: PkgxPackage = ${formatObjectWithoutQuotedKeys(packageInfo)}

export interface ${varName.charAt(0).toUpperCase() + varName.slice(1).replace(/Package$/, '').replace(/-/g, '')}Package {
  name: ${JSON.stringify(packageInfo.name)};
  domain: ${JSON.stringify(packageInfo.domain)};
  description: ${JSON.stringify(packageInfo.description)};
  packageYmlUrl: ${JSON.stringify(packageInfo.packageYmlUrl || '')};
  homepageUrl: ${JSON.stringify(packageInfo.homepageUrl || '')};
  githubUrl: ${JSON.stringify(packageInfo.githubUrl || '')};
  installCommand: ${JSON.stringify(packageInfo.installCommand)};
  programs: readonly ${Array.isArray(packageInfo.programs) && packageInfo.programs.length > 0
    ? `[${packageInfo.programs.map(p => JSON.stringify(p)).join(', ')}]`
    : '[]'};
  companions: readonly ${Array.isArray(packageInfo.companions) && packageInfo.companions.length > 0
    ? `[${packageInfo.companions.map(c => JSON.stringify(c)).join(', ')}]`
    : '[]'};
  dependencies: readonly ${Array.isArray(packageInfo.dependencies) && packageInfo.dependencies.length > 0
    ? `[${packageInfo.dependencies.map(d => JSON.stringify(d)).join(', ')}]`
    : '[]'};
  versions: readonly ${Array.isArray(packageInfo.versions) && packageInfo.versions.length > 0
    ? `[${packageInfo.versions.map(v => JSON.stringify(v)).join(', ')}]`
    : '[]'}${packageInfo.fullPath ? `;
  fullPath: ${JSON.stringify(packageInfo.fullPath || packageName)}` : ''}
}`

      // Write the file
      fs.writeFileSync(filePath, tsContent)
      console.error(`Successfully created package file for ${packageName}`)
      return true
    }

    // File exists, update it
    console.log(`Updating existing package file for ${packageName}`)

    // Read existing file
    const existingContent = fs.readFileSync(filePath, 'utf-8')

    // Get package variable name
    const varName = getPackageExportName(tsName)

    // Create the interface name - should match the existing format
    const interfaceName = `${varName.charAt(0).toUpperCase() + varName.slice(1).replace(/Package$/, '').replace(/-/g, '')}Package`

    // Create new package object content using our formatter
    const newPackageContent = formatObjectWithoutQuotedKeys(packageInfo)

    // Create the new interface content
    const newInterfaceContent = `export interface ${interfaceName} {
  name: ${JSON.stringify(packageInfo.name)};
  domain: ${JSON.stringify(packageInfo.domain)};
  description: ${JSON.stringify(packageInfo.description)};
  packageYmlUrl: ${JSON.stringify(packageInfo.packageYmlUrl || '')};
  homepageUrl: ${JSON.stringify(packageInfo.homepageUrl || '')};
  githubUrl: ${JSON.stringify(packageInfo.githubUrl || '')};
  installCommand: ${JSON.stringify(packageInfo.installCommand)};
  programs: readonly ${Array.isArray(packageInfo.programs) && packageInfo.programs.length > 0
    ? `[${packageInfo.programs.map(p => JSON.stringify(p)).join(', ')}]`
    : '[]'};
  companions: readonly ${Array.isArray(packageInfo.companions) && packageInfo.companions.length > 0
    ? `[${packageInfo.companions.map(c => JSON.stringify(c)).join(', ')}]`
    : '[]'};
  dependencies: readonly ${Array.isArray(packageInfo.dependencies) && packageInfo.dependencies.length > 0
    ? `[${packageInfo.dependencies.map(d => JSON.stringify(d)).join(', ')}]`
    : '[]'};
  versions: readonly ${Array.isArray(packageInfo.versions) && packageInfo.versions.length > 0
    ? `[${packageInfo.versions.map(v => JSON.stringify(v)).join(', ')}]`
    : '[]'}${packageInfo.fullPath ? `;
  fullPath: ${JSON.stringify(packageInfo.fullPath || packageName)}` : ''}
}`

    // First, remove all duplicated interface declarations from the file
    let cleanedContent = existingContent.replace(
      new RegExp(`export interface ${interfaceName} {[\\s\\S]+?\\n\\}`, 'gm'),
      ''
    );

    // Replace the package object in the cleaned file
    let updatedContent = cleanedContent.replace(
      new RegExp(`export const ${varName}[^{]+{[\\s\\S]+?\\n\\}`, 'm'),
      `export const ${varName}: PkgxPackage = ${newPackageContent}`
    );

    // Add the interface definition after the constant
    updatedContent = updatedContent.replace(
      new RegExp(`export const ${varName}[^{]+{[\\s\\S]+?\\n\\}`, 'm'),
      `export const ${varName}: PkgxPackage = ${newPackageContent}\n\n${newInterfaceContent}`
    );

    // Check if content actually changed
    if (updatedContent !== existingContent) {
      // Write the updated file
      fs.writeFileSync(filePath, updatedContent)
      console.error(`Updated package ${packageName} with new content`)
      return true
    }

    // Even though no changes were needed, this is still a success case
    console.log(`No changes needed for ${packageName}`)
    return true
  }
  catch (error) {
    console.error(`Error updating package ${packageName}:`, error)
    return false
  }
}

/**
 * Main function to update packages
 * @param singlePackage Optional name of a single package to update (skips fetching all packages)
 */
async function main(singlePackage?: string) {
  try {
    // Check if the packages directory exists
    if (!fs.existsSync(PACKAGES_DIR)) {
      fs.mkdirSync(PACKAGES_DIR, { recursive: true })
    }

    // If a single package is specified, just update that one
    if (singlePackage) {
      console.error(`Single package mode: only updating '${singlePackage}'`)
      const success = await updateSinglePackage(singlePackage)

      if (success) {
        console.error(`Successfully updated package '${singlePackage}'`)
      } else {
        console.error(`Failed to update package '${singlePackage}'`)
      }

      // Regenerate the index file
      console.error(`Regenerating index.ts file...`)
      await import('./generateIndex')
      await cleanupBrowserResources()
      return
    }

    // Otherwise, get the list of all packages to update
    const packages = await fetchPackageListFromGitHub()
    console.error(`Found ${packages.length} packages to update`)

    let updatedCount = 0
    const batches = Math.ceil(packages.length / BATCH_SIZE)

    // Process packages in batches to prevent memory issues
    for (let i = 0; i < batches; i++) {
      const start = i * BATCH_SIZE
      const end = Math.min(start + BATCH_SIZE, packages.length)
      const batch = packages.slice(start, end)

      console.error(`Processing batch ${i + 1}/${batches} (packages ${start + 1}-${end})`)

      // Update packages in the current batch
      const results = await Promise.all(batch.map((pkg: string) => updatePackage(pkg)))

      // Count updated packages
      updatedCount += results.filter(Boolean).length
    }

    console.error(`Updated ${updatedCount} out of ${packages.length} packages`)

    // Regenerate the index.ts file
    console.error(`Regenerating index.ts file...`)

    // Run the generateIndex script directly
    await import('./generateIndex')

    // Clean up resources
    await cleanupBrowserResources()

    console.error(`Package update completed successfully`)

    // Force exit after a small delay to ensure all resources are freed
    setTimeout(() => {
      process.exit(0)
    }, 1000)
  }
  catch (error) {
    console.error('Error updating packages:', error)

    // Make sure to clean up resources
    try {
      await cleanupBrowserResources()
    }
    catch (cleanupError) {
      console.error('Error during cleanup:', cleanupError)
    }

    process.exit(1)
  }
  finally {
    // Make sure to clean up browser resources
    try {
      await cleanupBrowserResources()

      // Force exit after resources are cleaned up
      setTimeout(() => {
        process.exit(0)
      }, 1000)
    }
    catch (error) {
      console.error('Error during final cleanup:', error)
      process.exit(1)
    }
  }
}

// Run the main function
// This function identifies valid package names, not executable paths
function isValidPackageName(arg: string): boolean {
  // Ignore executable paths
  if (arg.startsWith('/') || arg.includes('/bin/')) {
    return false
  }

  // Package names often have a domain structure or specific format
  return (
    // Check for domain-like format with dots
    /\w+\.\w+/.test(arg) ||
    // Check for path-like format with slashes, but not system paths
    (arg.includes('/') && !arg.startsWith('/')) ||
    // Check for common package names without domains
    ['node', 'bun', 'python', 'go', 'rust', 'ruby', 'php', 'perl', 'deno'].includes(arg)
  )
}

// Look for valid package names in command line args
const packageArg = process.argv.find(isValidPackageName)

if (packageArg) {
  // If a specific package name is provided, update only that package
  console.error(`Package name detected: ${packageArg}`)
  main(packageArg)
} else {
  // Otherwise update all packages
  main()
}
