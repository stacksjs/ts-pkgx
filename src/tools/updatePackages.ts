#!/usr/bin/env bun
/**
 * Script to update packages with latest data from pkgx.dev
 * Fetches the latest package info and regenerates the index.ts file
 */
import fs from 'node:fs'
import path from 'node:path'
import process from 'node:process'
import { cleanupBrowserResources, fetchPkgxPackage } from '../fetch'
import { fetchPackageListFromGitHub, formatObjectWithoutQuotedKeys } from '../utils'

// The packages directory path
const PACKAGES_DIR = path.join(process.cwd(), 'src', 'packages')

// Number of packages to update per batch to prevent memory issues
const BATCH_SIZE = 20

// Command line flags
const FLAGS = {
  force: process.argv.includes('--force') || process.argv.includes('-f')
}

/**
 * Generate the exported package name based on the module name
 * @param moduleName The module name (filename without extension)
 * @returns The actual exported package variable name
 */
export function getPackageExportName(moduleName: string): string {
  // Remove hyphens to create a valid JavaScript identifier
  // e.g., ast-grepgithubio.ts exports astgrepgithubioPackage
  return `${moduleName.replace(/-/g, '')}Package`
}

/**
 * Convert a domain name to a TypeScript-friendly filename
 * Handles special cases like nested paths and ensures valid identifier names
 * @param domainName The original domain name or path
 * @returns A TypeScript-friendly filename without extension
 */
function getDomainAsTypescriptFileName(domainName: string): string {
  // First handle the case where there are slashes (nested paths)
  if (domainName.includes('/')) {
    // Replace slashes with hyphens for filenames
    return domainName
      .replace(/\//g, '-')
      .replace(/\./g, '')
      .replace(/[^a-zA-Z0-9\-_]/g, '')
      .toLowerCase()
  }

  // For regular domains, just remove dots and special characters
  return domainName
    .replace(/\./g, '')
    .replace(/[^a-zA-Z0-9\-_]/g, '')
    .toLowerCase()
}

/**
 * Generate a complete package file with consistent formatting
 * @param packageInfo Package information to use for generation
 * @param tsName TypeScript-friendly name for the file
 * @returns String containing the entire file content
 */
export function generatePackageFile(packageInfo: Record<string, any>, tsName: string): string {
  // Create package variable name
  const varName = getPackageExportName(tsName)

  // Create interface name
  const interfaceName = `${varName.charAt(0).toUpperCase() + varName.slice(1).replace(/Package$/, '').replace(/-/g, '')}Package`

  // Generate array formats with proper indentation
  const formatArray = (arr: any[]) => {
    if (!arr || arr.length === 0) return '[]'

    // For single item arrays, keep them on one line
    if (arr.length === 1) {
      return `[${JSON.stringify(arr[0])}]`
    }

    // For multi-item arrays, format with line breaks and indentation
    return `[
    ${arr.map(item => JSON.stringify(item)).join(',\n    ')}
  ]`
  }

  // Create the full file content
  return `import type { PkgxPackage } from '../types'

/**
 * ${varName} information from pkgx.dev
 * Generated by pkgx-tools
 */
export const ${varName}: PkgxPackage = ${formatObjectWithoutQuotedKeys(packageInfo)}

export interface ${interfaceName} {
  name: ${JSON.stringify(packageInfo.name)};
  domain: ${JSON.stringify(packageInfo.domain)};
  description: ${JSON.stringify(packageInfo.description)};
  packageYmlUrl: ${JSON.stringify(packageInfo.packageYmlUrl || '')};
  homepageUrl: ${JSON.stringify(packageInfo.homepageUrl || '')};
  githubUrl: ${JSON.stringify(packageInfo.githubUrl || '')};
  installCommand: ${JSON.stringify(packageInfo.installCommand)};
  programs: readonly ${Array.isArray(packageInfo.programs) && packageInfo.programs.length > 0
    ? JSON.stringify(packageInfo.programs).replace(/^\[/, '[').replace(/\]$/, ']')
    : '[]'};
  companions: readonly ${Array.isArray(packageInfo.companions) && packageInfo.companions.length > 0
    ? JSON.stringify(packageInfo.companions).replace(/^\[/, '[').replace(/\]$/, ']')
    : '[]'};
  dependencies: readonly ${Array.isArray(packageInfo.dependencies) && packageInfo.dependencies.length > 0
    ? JSON.stringify(packageInfo.dependencies).replace(/^\[/, '[').replace(/\]$/, ']')
    : '[]'};
  versions: readonly ${Array.isArray(packageInfo.versions) && packageInfo.versions.length > 0
    ? JSON.stringify(packageInfo.versions).replace(/^\[/, '[').replace(/\]$/, ']')
    : '[]'}${packageInfo.fullPath ? `;
  fullPath: ${JSON.stringify(packageInfo.fullPath || packageInfo.name)}` : ''};
}
`
}

/**
 * Update a single package file with latest information
 * This function is a specialized version that only updates one package for use with CLI
 * @param packageName The name of the package to update
 * @returns Promise resolving to boolean indicating success
 */
export async function updatePackage(packageName: string): Promise<boolean> {
  try {
    console.log(`Updating package ${packageName}...`)

    // Validate that the package name is legitimate and not a path
    if (packageName.startsWith('/') || packageName.includes('/bin/')) {
      console.error(`Error: '${packageName}' appears to be a path, not a valid package name.`)
      return false
    }

    // Create packages directory if it doesn't exist
    if (!fs.existsSync(PACKAGES_DIR)) {
      fs.mkdirSync(PACKAGES_DIR, { recursive: true })
    }

    // Fetch the latest package information
    const { packageInfo, fullDomainName } = await fetchPkgxPackage(packageName, {
      timeout: 60000, // 60 second timeout
    })

    // Sort versions if they exist, using Bun.semver if available
    if (Array.isArray(packageInfo.versions) && packageInfo.versions.length > 0) {
      try {
        // Use Bun.semver to sort versions if available (descending order - newest first)
        if (typeof Bun !== 'undefined' && Bun.semver) {
          packageInfo.versions.sort((a, b) => -1 * Bun.semver.order(a, b))
        } else {
          // Fallback manual sorting when Bun.semver is not available
          packageInfo.versions.sort((a, b) => {
            const aParts = a.split('.').map(Number)
            const bParts = b.split('.').map(Number)

            for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
              const aVal = aParts[i] || 0
              const bVal = bParts[i] || 0
              if (aVal !== bVal) {
                return bVal - aVal // Descending order
              }
            }
            return 0
          })
        }
      } catch (err) {
        console.error(`Error sorting versions: ${err}`)
        // Continue with unsorted versions if sorting fails
      }
    }

    // Now use our updateSinglePackage helper function
    return await updateSinglePackage(packageInfo)
  }
  catch (error) {
    console.error(`Error updating package ${packageName}:`, error)
    return false
  }
}

/**
 * Extract basic package information from a file to regenerate it with proper formatting
 * @param filePath Path to the package file
 * @returns Package data object or null if extraction fails
 */
export function extractPackageDataFromFile(filePath: string): Record<string, any> | null {
  try {
    if (!fs.existsSync(filePath)) {
      console.error(`File not found: ${filePath}`);
      return null;
    }

    // Read the file content
    const content = fs.readFileSync(filePath, 'utf-8');

    // Extract essential fields
    const domain = extractValueFromContent(content, 'domain');
    if (!domain) {
      console.error(`Could not extract domain from ${filePath}`);
      return null;
    }

    const name = extractValueFromContent(content, 'name') || domain;

    // Create a package data object with all possible fields
    return {
      name,
      domain,
      description: extractValueFromContent(content, 'description') || '',
      packageYmlUrl: extractValueFromContent(content, 'packageYmlUrl') || '',
      homepageUrl: extractValueFromContent(content, 'homepageUrl') || '',
      githubUrl: extractValueFromContent(content, 'githubUrl') || '',
      installCommand: extractValueFromContent(content, 'installCommand') || '',
      programs: extractArrayFromContent(content, 'programs'),
      companions: extractArrayFromContent(content, 'companions'),
      dependencies: extractArrayFromContent(content, 'dependencies'),
      versions: extractArrayFromContent(content, 'versions'),
      fullPath: extractValueFromContent(content, 'fullPath') || domain
    };
  } catch (error) {
    console.error(`Error extracting package data from ${filePath}:`, error);
    return null;
  }
}

/**
 * Helper function to extract a string value from file content
 */
function extractValueFromContent(content: string, key: string): string {
  const regex = new RegExp(`${key}\\s*:\\s*"([^"]*)"`, 'i');
  const match = content.match(regex);
  return match && match[1] ? match[1] : '';
}

/**
 * Helper function to extract an array from file content
 */
function extractArrayFromContent(content: string, key: string): string[] {
  // Look for the array pattern in the content
  const regex = new RegExp(`${key}\\s*:\\s*\\[([^\\]]*)]`, 'i');
  const match = content.match(regex);

  if (!match || !match[1]) {
    return [];
  }

  // Parse the array items
  const itemsString = match[1].trim();
  if (!itemsString) {
    return [];
  }

  // Extract string items from the array
  const itemRegex = /"([^"]*)"/g;
  const items: string[] = [];
  let itemMatch;

  while ((itemMatch = itemRegex.exec(itemsString)) !== null) {
    items.push(itemMatch[1]);
  }

  return items;
}

/**
 * Update a single package's file
 * @param packageInfo Package information to write
 * @param aliasInfo Additional information about reverse aliases
 * @returns Promise resolving to a boolean indicating success
 */
async function updateSinglePackage(
  packageInfo: Record<string, any>,
  aliasInfo: { alias?: string; targetDomain?: string } = {}
): Promise<boolean> {
  try {
    const fullDomainName = packageInfo.domain;
    const tsName = getDomainAsTypescriptFileName(fullDomainName);
    const filePath = path.join(PACKAGES_DIR, `${tsName}.ts`);

    // Generate clean file content
    const fileContent = generatePackageFile(packageInfo, tsName);

    // If a file already exists, delete it first to ensure a completely clean state
    if (fs.existsSync(filePath)) {
      try {
        fs.unlinkSync(filePath);
        console.log(`Deleted existing file to ensure clean generation: ${filePath}`);
      } catch (err) {
        console.error(`Warning: Error deleting file: ${err}`);
        // Continue anyway - we'll overwrite it
      }
    } else {
      console.log(`Creating new package file for ${packageInfo.domain}`);
    }

    // Write the file with fresh content
    fs.writeFileSync(filePath, fileContent);
    console.log(`Successfully wrote ${tsName}.ts with clean content`);

    return true;
  }
  catch (error) {
    console.error(`Error updating package ${packageInfo.domain}:`, error);
    return false;
  }
}

/**
 * Force regenerates a package file with minimal data
 * This is a simpler version that always generates a clean file
 * @param packageName Name of the package to force fix
 */
export function forceFixProblematicFile(packageName: string): boolean {
  // Determine the filename
  let filename: string;
  if (packageName.includes('/')) {
    // Handle nested path like apple.com/remote_cmds
    const [domain, subPath] = packageName.split('/');
    filename = domain.replace(/\./g, '') + '-' + subPath.replace(/-/g, '_');
    filename = filename.toLowerCase();
  } else {
    // Regular domain
    filename = packageName.replace(/\./g, '').toLowerCase();
  }

  const filePath = path.join(PACKAGES_DIR, `${filename}.ts`);
  console.log(`Forcefully fixing file: ${filePath}`);

  // If the file exists, try to extract its data first
  let packageData;
  if (fs.existsSync(filePath)) {
    packageData = extractPackageDataFromFile(filePath);

    // Delete the existing file to ensure a clean state
    try {
      fs.unlinkSync(filePath);
      console.log(`Deleted existing file: ${filePath}`);
    } catch (error) {
      console.error(`Error deleting file: ${error}`);
      // Continue anyway
    }
  }

  // If we couldn't extract data, create minimal package data
  if (!packageData) {
    packageData = {
      name: packageName,
      domain: packageName,
      description: `Package information for ${packageName}`,
      packageYmlUrl: "",
      homepageUrl: "",
      githubUrl: "",
      installCommand: `pkgx ${packageName}`,
      programs: [],
      companions: [],
      dependencies: [],
      versions: []
    };
  }

  // Generate a clean file with a single interface
  const fileContent = generatePackageFile(packageData, filename);

  // Write the new file
  try {
    fs.writeFileSync(filePath, fileContent);
    console.log(`Created clean file: ${filePath}`);
    return true;
  } catch (error) {
    console.error(`Error writing file: ${error}`);
    return false;
  }
}
