/**
 * Generate PackageDomain and PackageName types from actual package files
 * This avoids TypeScript's limitations with large union types
 */
import fs from 'node:fs'
import path from 'node:path'
import process from 'node:process'

const PACKAGES_DIR = path.join(process.cwd(), 'src', 'packages')
const OUTPUT_FILE = path.join(process.cwd(), 'src', 'generated-package-names.ts')

interface PackageData {
  domain: string
  versions: readonly string[]
}

async function loadAllPackages(): Promise<Map<string, string[]>> {
  const domainToVersions = new Map<string, string[]>()

  async function scanDirectory(dir: string) {
    const entries = fs.readdirSync(dir, { withFileTypes: true })

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name)

      if (entry.isDirectory()) {
        await scanDirectory(fullPath)
      } else if (entry.isFile() && entry.name.endsWith('.ts') && entry.name !== 'index.ts' && entry.name !== 'aliases.ts') {
        try {
          const module = await import(fullPath)
          const packageExport = Object.values(module).find(
            (exp: any) => exp && typeof exp === 'object' && exp.domain
          ) as any

          if (packageExport && packageExport.domain && packageExport.versions) {
            domainToVersions.set(packageExport.domain, packageExport.versions)
          }
        } catch (error) {
          console.warn(`Failed to load ${fullPath}:`, error)
        }
      }
    }
  }

  await scanDirectory(PACKAGES_DIR)
  return domainToVersions
}

async function loadAliases(): Promise<Map<string, string>> {
  const aliasesPath = path.join(process.cwd(), 'src', 'packages', 'aliases.ts')
  const module = await import(aliasesPath)
  return new Map(Object.entries(module.aliases))
}

function generateTypes(domainToVersions: Map<string, string[]>, aliases: Map<string, string>): string {
  const lines: string[] = []

  lines.push('/**')
  lines.push(' * GENERATED FILE - DO NOT EDIT')
  lines.push(' * Generated by scripts/generate-package-types.ts')
  lines.push(' *')
  lines.push(' * This file contains pre-generated PackageDomain and PackageAlias types')
  lines.push(' * to avoid TypeScript limitations with large union types.')
  lines.push(' */')
  lines.push('')

  // Generate PackageDomain as a union of all domain strings
  const sortedDomains = Array.from(domainToVersions.keys()).sort()
  lines.push('/**')
  lines.push(' * All package domain names as a union type')
  lines.push(' */')
  lines.push(`export type GeneratedPackageDomain =`)
  for (let i = 0; i < sortedDomains.length; i++) {
    const domain = sortedDomains[i]
    const line = i === 0
      ? `  | '${domain}'`
      : `  | '${domain}'`
    lines.push(line)
  }
  lines.push('')

  // Generate PackageAlias
  const sortedAliases = Array.from(aliases.keys()).sort()
  lines.push('/**')
  lines.push(' * All package aliases as a union type')
  lines.push(' */')
  lines.push(`export type GeneratedPackageAlias =`)
  for (let i = 0; i < sortedAliases.length; i++) {
    const alias = sortedAliases[i]
    const line = i === 0
      ? `  | '${alias}'`
      : `  | '${alias}'`
    lines.push(line)
  }
  lines.push('')

  // Generate PackageName
  lines.push('/**')
  lines.push(' * All valid package identifiers (aliases + domains)')
  lines.push(' */')
  lines.push('export type GeneratedPackageName = GeneratedPackageAlias | GeneratedPackageDomain')
  lines.push('')

  // Generate domain to versions mapping interface
  lines.push('/**')
  lines.push(' * Pre-computed versions for each package domain')
  lines.push(' * This avoids TypeScript performance issues with large mapped types')
  lines.push(' */')
  lines.push('export interface GeneratedPackageVersions {')
  for (const [domain, versions] of Array.from(domainToVersions.entries()).sort((a, b) => a[0].localeCompare(b[0]))) {
    const versionUnion = versions.map(v => `'${v}'`).join(' | ')
    lines.push(`  '${domain}': ${versionUnion}`)
  }
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

async function main() {
  console.log('Loading all packages...')
  const domainToVersions = await loadAllPackages()
  console.log(`Loaded ${domainToVersions.size} package domains`)

  console.log('Loading aliases...')
  const aliases = await loadAliases()
  console.log(`Loaded ${aliases.size} aliases`)

  console.log('Generating types...')
  const typeDefinition = generateTypes(domainToVersions, aliases)

  console.log(`Writing to ${OUTPUT_FILE}...`)
  fs.writeFileSync(OUTPUT_FILE, typeDefinition, 'utf-8')

  console.log('âœ… Done! Package types generated successfully')
  console.log(`   File: ${OUTPUT_FILE}`)
  console.log(`   Domains: ${domainToVersions.size}`)
  console.log(`   Aliases: ${aliases.size}`)
}

main().catch(console.error)
