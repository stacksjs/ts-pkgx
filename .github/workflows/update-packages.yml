name: Update Packages

on:
  schedule:
    # Run hourly at minute 15
    - cron: '15 * * * *'
  # Allow manual trigger
  workflow_dispatch:

jobs:
  update-packages:
    name: Update packages and index
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed to push changes

    steps:
      - name: Debug workflow trigger
        run: |
          echo "=== Update Workflow Debug Information ==="
          echo "Event name: ${{ github.event_name }}"
          echo "Repository: ${{ github.repository }}"
          echo "Ref: ${{ github.ref }}"
          echo "SHA: ${{ github.sha }}"
          echo "Actor: ${{ github.actor }}"
          echo "Workflow: ${{ github.workflow }}"
          echo "Job: ${{ github.job }}"
          echo "Run ID: ${{ github.run_id }}"
          echo "Run number: ${{ github.run_number }}"
          echo "Current time: $(date)"
          echo "============================================="

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Install Playwright browsers
        run: bunx playwright install chromium --with-deps

      - name: Show initial git status
        run: |
          echo "=== Initial Git Status ==="
          git status --porcelain
          echo "=== End Initial Git Status ==="

      - name: Fetch all packages
        id: fetch-packages
        run: |
          echo "Starting package fetch..."

          # Create a temporary file to capture the JSON output safely
          TEMP_JSON_FILE=$(mktemp)

          # Capture the JSON output from the fetch command to a file
          if bun bin/cli.ts fetch --all --verbose --concurrency 10 --timeout 10000 --output-json > "$TEMP_JSON_FILE" 2>/dev/null; then
            echo "Fetch command completed successfully"
          else
            echo "Fetch command failed, creating error JSON"
            echo '{"success":false,"error":"fetch failed"}' > "$TEMP_JSON_FILE"
          fi

          # Read the JSON from the file (this handles newlines properly)
          FETCH_RESULT=$(cat "$TEMP_JSON_FILE")

          echo "Fetch command completed. Result:"
          echo "$FETCH_RESULT"

          # Use the file content for GitHub output (safer for multiline content)
          echo "fetch_result<<EOF" >> $GITHUB_OUTPUT
          cat "$TEMP_JSON_FILE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Clean up temp file
          rm -f "$TEMP_JSON_FILE"

          # Also run without JSON for normal logging (to stderr so it doesn't interfere with JSON)
          echo "Running fetch command again for detailed logging..."
          bun bin/cli.ts fetch --all --verbose --concurrency 10 --timeout 10000 >&2 || true
        timeout-minutes: 45

      - name: Show git status after fetch
        run: |
          echo "=== Git Status After Fetch ==="
          git status --porcelain
          echo "=== End Git Status After Fetch ==="

      - name: Generate index
        run: bun bin/cli.ts generate-index
        timeout-minutes: 5

      - name: Generate aliases
        run: bun bin/cli.ts generate-aliases
        timeout-minutes: 5

      - name: Generate documentation
        run: bun bin/cli.ts generate-docs
        timeout-minutes: 5

      - name: Show git status after all generation
        run: |
          echo "=== Git Status After All Generation ==="
          git status --porcelain
          echo "=== End Git Status After All Generation ==="

      - name: Generate commit message
        id: commit-message
        run: |
          # Parse the fetch results - handle multiline JSON safely
          FETCH_RESULT=$(cat << 'EOF'
          ${{ steps.fetch-packages.outputs.fetch_result }}
          EOF
          )

          # Debug: Show abbreviated fetch result
          echo "Fetch result status check..."

          # Check if the fetch was successful
          FETCH_SUCCESS=$(echo "$FETCH_RESULT" | jq -r '.success // false' 2>/dev/null)

          if [ "$FETCH_SUCCESS" != "true" ]; then
            echo "Fetch was not successful, skipping commit"
            echo "commit_message=chore: fetch failed" >> $GITHUB_OUTPUT
            echo "total_updated=0" >> $GITHUB_OUTPUT
            echo "should_commit=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract package counts and summary info
          TOTAL_UPDATED=$(echo "$FETCH_RESULT" | jq -r '.totalUpdated // 0' 2>/dev/null)
          TOTAL_PROCESSED=$(echo "$FETCH_RESULT" | jq -r '.totalProcessed // 0' 2>/dev/null)

          # Extract first few package names for commit message (sanitize for shell safety)
          UPDATED_PACKAGES=$(echo "$FETCH_RESULT" | jq -r '.updatedPackagesMixed[]? // .updatedPackages[]? // empty' 2>/dev/null | head -20 | tr -d '\n\r' | tr ' ' '_')

          # Debug output
          echo "Total packages processed: $TOTAL_PROCESSED"
          echo "Total packages updated: $TOTAL_UPDATED"
          echo "Sample updated packages: $(echo "$UPDATED_PACKAGES" | head -5 | tr '\n' ' ')"

          # Generate commit message based on update count
          if [ "$TOTAL_UPDATED" -eq 0 ]; then
            echo "No packages were updated (all from cache)"
            COMMIT_MSG="chore: update packages (no changes detected)"
            SHOULD_COMMIT="false"
          elif [ "$TOTAL_UPDATED" -le 3 ]; then
            # For small numbers, list all packages
            PACKAGE_LIST=$(echo "$UPDATED_PACKAGES" | head -3 | paste -sd ',' - | sed 's/,/, /g')
            COMMIT_MSG="chore: update $PACKAGE_LIST"
            SHOULD_COMMIT="true"
          elif [ "$TOTAL_UPDATED" -le 8 ]; then
            # For medium numbers, list first few and count the rest
            FIRST_PACKAGES=$(echo "$UPDATED_PACKAGES" | head -4 | paste -sd ',' - | sed 's/,/, /g')
            REMAINING=$((TOTAL_UPDATED - 4))
            if [ "$REMAINING" -eq 1 ]; then
              COMMIT_MSG="chore: update $FIRST_PACKAGES and 1 other dep"
            else
              COMMIT_MSG="chore: update $FIRST_PACKAGES and $REMAINING other deps"
            fi
            SHOULD_COMMIT="true"
          else
            # For large numbers, list first few and count the rest
            FIRST_PACKAGES=$(echo "$UPDATED_PACKAGES" | head -3 | paste -sd ',' - | sed 's/,/, /g')
            REMAINING=$((TOTAL_UPDATED - 3))
            COMMIT_MSG="chore: update $FIRST_PACKAGES and $REMAINING other deps"
            SHOULD_COMMIT="true"
          fi

          echo "commit_message=$COMMIT_MSG" >> $GITHUB_OUTPUT
          echo "total_updated=$TOTAL_UPDATED" >> $GITHUB_OUTPUT
          echo "should_commit=$SHOULD_COMMIT" >> $GITHUB_OUTPUT

          # Final debug output
          echo "Generated commit message: $COMMIT_MSG"
          echo "Should commit: $SHOULD_COMMIT"

      - name: Check for changes
        id: git-check
        run: |
          # Show git status for debugging
          echo "Git status:"
          git status --porcelain

          # Check for changes in the specific directories we care about
          CHANGES=$(git status --porcelain src/packages/ docs/ 2>/dev/null || echo "")

          if [[ -z "$CHANGES" ]]; then
            echo "No changes detected in src/packages/ or docs/"
            echo "changes=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected:"
            echo "$CHANGES"
            echo "changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit and push changes
        if: steps.git-check.outputs.changes == 'true' && steps.commit-message.outputs.should_commit == 'true'
        run: |
          SHOULD_COMMIT="${{ steps.commit-message.outputs.should_commit }}"
          TOTAL_UPDATED="${{ steps.commit-message.outputs.total_updated }}"

          echo "Should commit based on package updates: $SHOULD_COMMIT"
          echo "Total packages updated: $TOTAL_UPDATED"
          echo "Git changes detected: ${{ steps.git-check.outputs.changes }}"

          # Configure git for the action
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Add and commit changes
          git add src/packages/ docs/
          git commit -m "${{ steps.commit-message.outputs.commit_message }}" -m "Automated update via GitHub Actions workflow"

          # Push changes
          git push origin main

          echo "Successfully committed and pushed changes"
